# 架构决策记录 (Architecture Decision Records)

## ADR-001: 进程内多Raft实例架构

**日期**: 2025-06-24
**状态**: 已接受
**决策者**: 开发团队

### 背景
传统的分布式Raft实现通常采用多进程部署，每个节点运行独立的进程，通过网络进行通信。但对于WAL场景，我们需要超低延迟的性能。

### 决策
采用单进程内运行多个Raft实例的架构，通过共享内存进行通信。

### 理由
1. **性能优势**: 共享内存通信延迟 < 100ns，网络通信 > 10μs
2. **简化部署**: 单一可执行文件，无需复杂网络配置
3. **资源效率**: 共享内存池、线程池等系统资源
4. **一致性保证**: 通过原子操作保证强一致性

### 后果
- **正面影响**: 极低延迟、高吞吐量、简化运维
- **负面影响**: 不支持真正的分布式部署、单点故障风险
- **缓解措施**: 通过进程级容错和快速重启机制降低风险

---

## ADR-002: 文件前缀式数据组织

**日期**: 2025-06-24
**状态**: 已接受
**决策者**: 开发团队

### 背景
Raft协议需要存储多种类型的数据：日志、状态、快照、元数据。传统方案使用目录结构组织。

### 决策
采用扁平化的文件前缀命名方案，不使用目录结构。

**命名规范**:
- 日志: `{device_prefix}log_{index}`
- 状态: `{device_prefix}state_{key}`
- 快照: `{device_prefix}snap_{index}`
- 元数据: `{device_prefix}meta_{key}`

### 理由
1. **性能优化**: 避免目录遍历开销
2. **简化实现**: 统一的文件操作接口
3. **后端兼容**: 所有存储后端都支持文件操作
4. **灵活路由**: 可根据前缀将不同数据路由到不同后端

### 后果
- **正面影响**: 简化代码、提升性能、增强灵活性
- **负面影响**: 文件名较长、缺少层次结构
- **缓解措施**: 通过文件名索引和智能缓存优化访问

---

## ADR-003: 三层存储抽象架构

**日期**: 2025-06-24
**状态**: 已接受
**决策者**: 开发团队

### 背景
需要支持多种存储后端（NVMe-oF、NFS、本地文件），同时为Raft提供统一接口。

### 决策
采用三层存储抽象架构：
1. **Raft存储适配器**: 提供Raft语义化接口
2. **存储管理器**: 统一后端管理和路由
3. **存储后端**: 具体的存储实现

### 理由
1. **分离关注点**: 每层专注于特定职责
2. **可扩展性**: 易于添加新的存储后端
3. **灵活性**: 支持复杂的路由和优化策略
4. **可测试性**: 每层可独立测试

### 后果
- **正面影响**: 架构清晰、易于扩展、职责明确
- **负面影响**: 增加了复杂性和调用开销
- **缓解措施**: 通过内联优化和缓存减少开销

---

## ADR-004: 批量+异步I/O优化策略

**日期**: 2025-06-24
**状态**: 已接受
**决策者**: 开发团队

### 背景
WAL场景需要高吞吐量的写入性能，单个I/O操作无法充分利用存储设备性能。

### 决策
采用批量I/O聚合和异步处理策略：
- 自动聚合小的I/O请求
- 异步执行I/O操作
- 分层缓冲机制

### 理由
1. **性能提升**: 批量I/O可以显著提升吞吐量
2. **延迟优化**: 异步处理避免阻塞
3. **资源利用**: 更好地利用存储设备并发能力
4. **可配置**: 可根据场景调整批量大小和超时

### 后果
- **正面影响**: 大幅提升I/O性能
- **负面影响**: 增加内存使用和复杂性
- **缓解措施**: 智能批量策略和内存管理

---

## ADR-005: C语言作为主要开发语言

**日期**: 2025-06-24
**状态**: 已接受
**决策者**: 开发团队

### 背景
xDevice是一个高性能WAL分布式块设备，需要极致的性能和精确的资源控制。

### 决策
选择C语言作为主要开发语言。

### 理由
1. **极致性能**: 接近机器码的执行效率
2. **精确控制**: 对内存、CPU的精确控制
3. **系统集成**: 与操作系统和硬件的良好集成
4. **稳定性**: 成熟的语言和工具链
5. **可移植性**: 广泛的平台支持

### 后果
- **正面影响**: 最优性能、精确控制、广泛兼容
- **负面影响**: 开发复杂度高、内存安全风险
- **缓解措施**: 严格的代码审查、内存检查工具、单元测试

---

## ADR-006: 多级持久性保证

**日期**: 2025-06-24
**状态**: 已接受
**决策者**: 开发团队

### 背景
不同的数据类型对持久性有不同要求，需要平衡性能和可靠性。

### 决策
提供四级持久性保证：
1. **NONE**: 无持久性保证（最快）
2. **BUFFER_SYNC**: 缓冲区同步
3. **FILE_SYNC**: 文件同步
4. **DEVICE_SYNC**: 设备级同步（最安全）

### 理由
1. **灵活性**: 应用可根据需要选择合适级别
2. **性能**: 避免不必要的同步开销
3. **可靠性**: 关键数据可选择高级别保证
4. **兼容性**: 支持不同存储后端的特性

### 后果
- **正面影响**: 性能和可靠性的灵活平衡
- **负面影响**: 增加配置复杂性
- **缓解措施**: 提供合理的默认配置和文档

---

## ADR-007: 原子操作和锁策略

**日期**: 2025-06-24
**状态**: 已接受
**决策者**: 开发团队

### 背景
进程内多线程环境需要保证数据一致性，同时追求高性能。

### 决策
采用混合的同步策略：
- 关键路径使用无锁原子操作
- 复杂操作使用读写锁
- 批量操作使用事务性保证

### 理由
1. **性能**: 原子操作比锁更快
2. **正确性**: 避免数据竞争和不一致
3. **可扩展性**: 减少锁竞争
4. **灵活性**: 根据场景选择合适策略

### 后果
- **正面影响**: 高性能、强一致性
- **负面影响**: 增加编程复杂性
- **缓解措施**: 封装同步原语、充分测试

---

## ADR-008: 监控和可观测性设计

**日期**: 2025-06-24
**状态**: 已接受
**决策者**: 开发团队

### 背景
生产环境需要丰富的监控指标来诊断性能问题和故障。

### 决策
构建完整的监控系统：
- 多维度性能指标收集
- 延迟直方图统计
- Prometheus格式导出
- 实时告警机制

### 理由
1. **可观测性**: 全面了解系统运行状态
2. **性能优化**: 数据驱动的优化决策
3. **故障诊断**: 快速定位和解决问题
4. **标准化**: 兼容主流监控工具链

### 后果
- **正面影响**: 提高运维效率、系统可靠性
- **负面影响**: 增加系统开销和复杂性
- **缓解措施**: 可配置的监控级别、异步统计收集

---

## ADR-009: WAL导向的存储管理策略

**日期**: 2025-06-24
**状态**: 已接受
**决策者**: 开发团队

### 背景
之前的设计将xDevice定位为通用分布式存储，但实际目标是为应用提供分布式WAL设备。通用设计导致了文件粒度过细、存储分散、缺乏WAL语义等问题。

### 决策
采用WAL导向的存储管理策略：
1. **统一地址空间**: 每个Raft实例管理连续的虚拟地址空间
2. **WAL即存储**: Raft日志就是应用WAL的分布式副本
3. **智能分层**: 根据数据热度自动选择存储后端
4. **段式管理**: 使用段来组织WAL数据，优化I/O性能

### 理由
1. **性能优化**: 顺序分配和批量I/O提升WAL写入性能
2. **简化架构**: 消除Raft日志和应用WAL的重复存储
3. **智能管理**: 热数据使用NVMe-oF，冷数据使用本地存储
4. **WAL语义**: 直接支持append、read、sync、truncate操作
5. **透明复制**: 应用无需关心分布式细节

### 核心组件
- **虚拟地址空间**: 统一的逻辑地址到物理地址映射
- **段管理器**: 管理WAL数据段的生命周期
- **分层存储**: 自动在热/温/冷存储间迁移数据
- **WAL设备接口**: 为应用提供标准WAL语义

### 后果
- **正面影响**: 极大提升WAL性能、简化应用集成、优化存储利用
- **负面影响**: 增加存储管理复杂性、需要复杂的地址映射
- **缓解措施**: 完善的测试、监控和故障恢复机制

---

## ADR-006: WAL优化的本地存储后端

**日期**: 2025-06-24
**状态**: 已接受
**决策者**: 开发团队

### 背景
传统文件系统为长期存储设计，在WAL场景下存在显著性能问题：
1. **频繁元数据操作**: 创建/删除文件导致大量元数据操作开销
2. **存储碎片化**: 文件分散存储导致顺序性能下降  
3. **缓存污染**: 短期数据污染页缓存，影响其他应用
4. **同步开销**: fsync操作阻塞，延迟高
5. **空间回收慢**: 删除文件后空间回收不及时

### 决策
设计专门针对WAL场景优化的本地存储后端，核心特性包括：

1. **段式文件管理**
   - 预分配大段文件（64MB），避免频繁文件创建
   - 段内顺序分配，保证写入的局部性
   - 段池复用，快速分配和回收

2. **生命周期感知存储**
   - 跟踪检查点进度，预测数据失效时间
   - 整段回收过期数据，避免文件系统碎片
   - 零拷贝回收：使用fallocate PUNCH_HOLE快速清零

3. **快速写入路径** 
   - 内存写入缓冲区，批量刷新到磁盘
   - 超快顺序写入路径，延迟 < 200μs
   - 异步刷新机制，避免阻塞

4. **批量操作优化**
   - 智能批量调度，减少系统调用
   - 向量化I/O（writev），提高带宽利用率
   - 批量同步，降低fsync开销

5. **零碎片化设计**
   - 段大小层级管理，避免外部碎片
   - 预测性段分配，根据写入模式选择段大小
   - 智能段合并，定期整理碎片

### 理由
1. **极致性能**: 预期延迟从毫秒级降至微秒级，IOPS提升10-50倍
2. **WAL特性匹配**: 充分利用WAL数据的短生命周期特性
3. **资源效率**: 减少内存开销，提高磁盘利用率
4. **运维简化**: 自动垃圾回收，无需手动清理

### 设计要点

#### 段式管理架构
```c
typedef struct {
    uint32_t segment_id;           // 段ID
    uint64_t start_offset;         // 起始偏移量  
    uint64_t current_offset;       // 当前写入偏移
    uint64_t segment_size;         // 段大小
    bool is_sealed;                // 是否已封装
    bool is_recyclable;            // 是否可回收
    int fd;                        // 文件描述符
} wal_segment_t;
```

#### 快速写入路径
- 写入缓冲区：4MB内存缓冲，批量刷新
- 顺序检测：检测顺序写入，启用快速路径
- 异步刷新：达到阈值(80%)时触发异步刷新

#### 生命周期管理
- 检查点跟踪：根据Raft检查点标记过期段
- 批量清理：定期批量回收过期段
- 预测清理：根据历史模式预测清理时间

#### 性能目标
- 顺序写入延迟：50-200μs (相比传统1-5ms)
- 顺序写入IOPS：50K-200K (相比传统1K-10K)  
- 段清理延迟：1-10ms (相比传统100ms-1s)
- 空间回收：微秒级 (相比传统秒级)

### 后果
- **正面影响**: 
  - 10-100倍性能提升
  - 自动垃圾回收，运维简化
  - 内存和磁盘利用率提升
  - 完全兼容现有存储接口

- **负面影响**:
  - 增加20-50%内存开销
  - 实现复杂度提升
  - 只适用于WAL类场景

- **缓解措施**:
  - 可配置的资源限制
  - 渐进式回退到传统模式
  - 详细的性能监控和调优

### 适用场景
- ✅ 数据库WAL日志
- ✅ 分布式系统复制日志  
- ✅ 流处理系统持久化
- ✅ 时序数据库写入
- ❌ 长期存储需求
- ❌ 随机读写为主
- ❌ 内存敏感环境

---

## 决策状态说明

- **提议**: 决策正在考虑中
- **已接受**: 决策已被采纳并实施
- **已废弃**: 决策不再使用，被其他决策取代
- **已替代**: 决策被更好的方案替代

## 评审流程

1. **提出**: 任何团队成员可提出架构决策
2. **讨论**: 团队内部充分讨论利弊
3. **决策**: 达成一致后正式采纳
4. **记录**: 在此文档中记录决策内容
5. **实施**: 在代码中实现决策
6. **评估**: 定期评估决策效果，必要时修订

### 决策
选择C语言作为主要开发语言。

### 理由
**优势**:
- 零抽象成本，直接控制硬件资源
- 极致的性能，适合系统级编程
- 精确的内存管理，避免GC停顿
- 广泛的系统调用支持
- 丰富的网络和存储库生态

**劣势**:
- 开发效率相对较低
- 内存安全需要特别注意
- 并发编程复杂度较高

### 后果
- 需要建立严格的代码审查和测试流程
- 需要使用静态分析工具(valgrind, AddressSanitizer)
- 开发周期可能较长但性能表现优异

---

## ADR-002: 选择Raft作为一致性协议

**状态**: 已决定  
**日期**: 2024-06-24  
**决策者**: 核心团队

### 背景
分布式系统需要强一致性保证，需要选择合适的共识协议。

### 决策
采用Raft协议作为分布式一致性解决方案。

### 理由
**选择Raft的原因**:
- 算法理解相对简单，便于实现和调试
- 强领导者模型，简化了日志复制逻辑
- 成熟的工程实践，有大量参考实现
- 支持成员变更和日志压缩

**与其他协议对比**:
- vs Paxos: Raft更易理解和实现
- vs PBFT: Raft更适合崩溃故障模型
- vs EPaxos: Raft的工程实践更成熟

### 后果
- 写操作需要过半数节点确认，影响延迟
- 需要实现领导者选举、日志复制、快照等机制
- 节点故障时需要重新选举领导者

---

## ADR-003: 采用WAL优先的存储架构

**状态**: 已决定  
**日期**: 2024-06-24  
**决策者**: 核心团队

### 背景
系统主要面向WAL场景，需要针对顺序写入进行优化。

### 决策
采用WAL优先的存储架构，所有写入先记录WAL再更新数据。

### 理由
**WAL优势**:
- 顺序写入性能优异，特别适合机械硬盘
- 提供事务的原子性和持久性保证
- 支持高效的故障恢复机制
- 便于实现分布式日志复制

**架构特点**:
- WAL文件采用段文件组织，支持并发写入
- 数据文件采用LSM-Tree样式组织
- 支持异步刷盘和批量提交

### 后果
- 每次写入需要两次I/O操作(WAL + 数据)
- 需要实现WAL回放和检查点机制
- 存储空间会有一定的放大效应

---

## ADR-004: 使用自定义网络协议

**状态**: 已决定  
**日期**: 2024-06-24  
**决策者**: 核心团队

### 背景
系统需要高性能的网络通信，需要选择合适的协议栈。

### 决策
基于TCP实现自定义应用层协议，而不是使用HTTP/gRPC等通用协议。

### 理由
**自定义协议优势**:
- 极致的性能优化，减少不必要的开销
- 支持批量操作和流水线处理
- 紧凑的二进制格式，减少网络传输
- 支持优先级调度和流控机制

**vs 其他方案**:
- vs HTTP: 自定义协议开销更小
- vs gRPC: 避免protobuf序列化开销
- vs RDMA: TCP更通用，部署简单

### 后果
- 需要实现完整的协议栈(连接管理、重传、流控等)
- 调试和监控相对复杂
- 需要实现多种语言的客户端库

---

## ADR-005: 采用多级缓存架构

**状态**: 已决定  
**日期**: 2024-06-24  
**决策者**: 核心团队

### 背景
为了提升读取性能，需要设计高效的缓存架构。

### 决策
采用L1(热数据) + L2(暖数据) + 写缓存的多级缓存架构。

### 理由
**多级缓存优势**:
- L1缓存针对热点数据优化，使用更快的算法
- L2缓存提供更大的容量，缓存更多数据
- 写缓存支持批量写入优化
- 支持预取和自适应策略

**缓存策略**:
- L1使用LRU-K算法，L2使用ARC算法
- 支持布隆过滤器减少无效查找
- 异步预取基于访问模式预测

### 后果
- 内存使用量较大
- 缓存一致性维护复杂
- 需要监控缓存命中率和调优

---

## ADR-006: 支持在线压缩和合并

**状态**: 已决定  
**日期**: 2024-06-24  
**决策者**: 核心团队

### 背景
长期运行后，存储文件可能碎片化，需要合并机制。

### 决策
支持在线的数据压缩和文件合并，不影响正常服务。

### 理由
**在线合并优势**:
- 减少存储空间占用
- 提升读取性能(减少文件数量)
- 支持数据压缩减少I/O
- 后台运行不影响前台服务

**实现策略**:
- 采用类似LSM-Tree的层级合并
- 支持LZ4/ZSTD等高效压缩算法
- 基于负载自适应调整合并频率

### 后果
- 合并过程消耗CPU和I/O资源
- 需要仔细控制合并时机和强度
- 实现复杂度较高

---

## ADR-007: 事务支持和MVCC

**状态**: 讨论中  
**日期**: 2024-06-24  
**决策者**: 核心团队

### 背景
某些应用场景可能需要事务支持，需要评估是否实现。

### 选项
1. **完全不支持事务** - 保持简单性
2. **支持单机事务** - 基于WAL实现原子性
3. **支持分布式事务** - 实现两阶段提交
4. **支持MVCC** - 多版本并发控制

### 倾向
优先实现单机事务，后续考虑MVCC支持。

### 理由
- WAL场景对事务需求不高
- 事务会增加系统复杂度
- 可以作为后续版本的增强功能

---

## 技术选型总结

| 组件 | 选择 | 主要原因 |
|------|------|----------|
| 编程语言 | C语言 | 极致性能和资源控制 |
| 一致性协议 | Raft | 易理解、成熟、强一致性 |
| 存储架构 | WAL优先 | 适配WAL场景，高性能写入 |
| 网络协议 | 自定义TCP | 最优性能，支持批量操作 |
| 缓存架构 | 多级缓存 | 平衡性能和内存使用 |
| 数据组织 | LSM-Tree样式 | 高写入性能，支持合并 |
| 压缩算法 | LZ4/ZSTD | 平衡压缩比和性能 |
| 索引结构 | B+树 + 布隆过滤器 | 范围查询和快速过滤 |

这些技术决策记录为xDevice项目提供了清晰的技术方向和实现指导。
